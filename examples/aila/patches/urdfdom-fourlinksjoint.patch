--- urdf_parser/src/joint.cpp
+++ urdf_parser/src/joint.cpp
@@ -374,6 +374,118 @@
   return true;
 }
 
+bool parseDescription4Link(Joint4LinksDescription &j4ld, TiXmlElement* config)
+{
+	j4ld.clear();
+
+	// Get d
+	const char* d_str = config->Attribute("d");
+	if (d_str == NULL)
+	{
+	    logError("joint 4 links description: no d attribute specified");
+	    j4ld.clear();
+	    return false;
+	}
+	else
+	{
+	    try
+	    {
+		j4ld.d = boost::lexical_cast<double>(d_str);
+	    }
+	    catch (boost::bad_lexical_cast &e)
+	    {
+		logError("d attribute (%s) is not a float",d_str);
+		return false;
+	    }
+	}
+
+	// Get l
+	const char* l_str = config->Attribute("l");
+	if (l_str == NULL)
+	{
+	    logError("joint 4 links description: no l attribute specified");
+	    j4ld.clear();
+	    return false;
+	}
+	else
+	{
+	    try
+	    {
+		j4ld.l = boost::lexical_cast<double>(l_str);
+	    }
+	    catch (boost::bad_lexical_cast &e)
+	    {
+		logError("l attribute (%s) is not a float",l_str);
+		return false;
+	    }
+	}
+
+	// Get r1
+	const char* r1_str = config->Attribute("r1");
+	if (l_str == NULL)
+	{
+	    logError("joint 4 links description: no r1 attribute specified");
+	    j4ld.clear();
+	    return false;
+	}
+	else
+	{
+	    try
+	    {
+		j4ld.r1 = boost::lexical_cast<double>(r1_str);
+	    }
+	    catch (boost::bad_lexical_cast &e)
+	    {
+		logError("r1 attribute (%s) is not a float",r1_str);
+		return false;
+	    }
+	}
+
+	// Get r2
+	const char* r2_str = config->Attribute("r2");
+	if (l_str == NULL)
+	{
+	    logError("joint 4 links description: no r2 attribute specified");
+	    j4ld.clear();
+	    return false;
+	}
+	else
+	{
+	    try
+	    {
+		j4ld.r2 = boost::lexical_cast<double>(r2_str);
+	    }
+	    catch (boost::bad_lexical_cast &e)
+	    {
+		logError("r2 attribute (%s) is not a float",r2_str);
+		return false;
+	    }
+	}
+
+	// Get theta
+	const char* theta_str = config->Attribute("theta");
+	if (l_str == NULL)
+	{
+	    logError("joint 4 links description: no theta attribute specified");
+	    j4ld.clear();
+	    return false;
+	}
+	else
+	{
+	    try
+	    {
+		j4ld.theta = boost::lexical_cast<double>(theta_str);
+	    }
+	    catch (boost::bad_lexical_cast &e)
+	    {
+		logError("theta attribute (%s) is not a float",theta_str);
+		return false;
+	    }
+	}
+
+	return true;
+}
+
 bool parseJoint(Joint &joint, TiXmlElement* config)
 {
   joint.clear();
@@ -455,6 +567,8 @@
     joint.type = Joint::PRISMATIC;
   else if (type_str == "fixed")
     joint.type = Joint::FIXED;
+  else if (type_str == "fourlinks")
+    joint.type = Joint::FOURLINKS;
   else
   {
     logError("Joint [%s] has no known type [%s]", joint.name.c_str(), type_str.c_str());
@@ -558,6 +672,21 @@
       return false;
     }
   }
+
+  // Get Description4l
+  TiXmlElement *desc_xml = config->FirstChildElement("description4l");
+  if (desc_xml)
+  {
+      joint.description4l.reset(new Joint4LinksDescription);
+      if (!parseDescription4Link(*joint.description4l, desc_xml))
+      {
+           logError("Could not parse jdescription4l element for joint '%s'", joint.name.c_str());
+           joint.description4l.reset();
+           return false;
+      
+      }
+  }
+  //////////////////////////////////////////////////////////////////////////////////////
 
   return true;
 }
