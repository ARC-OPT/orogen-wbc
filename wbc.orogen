

name "wbc"

using_library "wbc"
using_library "wbc_common"

import_types_from "wbc/ConstraintConfig.hpp"
import_types_from "wbc/Constraint.hpp"
import_types_from "wbc_common/CartesianState.hpp"
import_types_from "wbc/RobotModelConfig.hpp"
import_types_from "wbc_common/QuadraticProgram.hpp"
import_types_from "base"

#
# Base WBC Task.
#
#  configureHook:
#
#  1. Load and configure robot models
#  2. Configure wbc scene
#  3. Create dynamic ports
#
#  updateHook:
#
#  1. Read input ports
#  2. Update robot models
#  3. Update constraints and send them to the solver
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("joint_names", "std/vector<std/string>").
       doc("Optionally set the order of joints here. If empty, order will be as in the robot model.")

    property("base_frame", "std/string")
       doc("Name of the robot base frame; all computations will be performed with respect to this frame. If empty, base frame will be the base frame of the first given robot model.")

    property("robot_models", "std/vector<wbc/RobotModelConfig>").
        doc("Add multiple robot and/or object models.")

    property("initial_joint_weights", "base/VectorXd").
        doc("The joint weights control the contribution of each individual joint to the task solution. Values have to be within (0 <= wq <= 1). A zero means here that the joint is not used at all. Size has to be same as number of robot joints or empty, in which case each joint weight is set to 1.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcTask will dynamically create the following ports for each constraint:
             Cartesian constraints:
                 [in] Reference Input (/wbc/CartesianState):         ref_<constraint_name>
                 [in] Weights (/base/VectorXd):                      weight_<constraint_name>
                 [in] Activation function (double):                  activation_<constraint_name>
                 [out] Constraint pose output (/wbc/CartesianState): status_<constraint_name>
             Joint Space constraints:
                 [in] Reference Input (/base/samples/Joints):            ref_<task_name>
                 [in] Weights (/base/VectorXd):                          weight_<task_name>
                 [in] Activation function (double):                      activation_<task_name>
                 [out] Current joint state output (base/samples/Joints): status_<task_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/wbc/CartesianState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/wbc/CartesianState"
    dynamic_output_port /.*/, "/base/samples/Joints"

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required. All configured joints have to be in this vector.")

    input_port("solver_output", "base/commands/Joints").
       doc("Computed solver output. Is used to compute the status of the constraint for debug purposes")
   
    input_port("joint_weights", "base/VectorXd").
       doc("Update joint weight values. Size has to be same number of joints.")

    output_port("computation_time", "double").
       doc("Debug: Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Debug: Actual cycle time between two consecutive calls of updateHook() in seconds")

    output_port("hierarchical_qp", "wbc/HierarchicalQP").
        doc("Output quadratic program for the solver.")

    output_port("current_joint_weights", "base/VectorXd").
        doc("Current joint weight vector")

    operation("activateConstraint").
       argument("constraint_name", "std/string").
       argument("activation", "double")

    operation("activateConstraints").
       argument("constraint_names", "std/vector<std/string>").
       argument("activation", "double")

    operation("deactivateAllConstraints")

    periodic 0.01
end


#
# Velocity based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcVelocityTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end


#
# Acceleration based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcAccelerationTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end

typekit do
   export_types "wbc/Constraint"
end

