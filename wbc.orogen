name "wbc"

import_types_from "wbc/common/ConstraintConfig.hpp"
import_types_from "wbc/common/Constraint.hpp"
import_types_from "wbc/common/TaskFrame.hpp"
import_types_from "wbc/robot_models/RobotModelConfig.hpp"
import_types_from "base"
using_library "wbc"
using_library "kdl_conversions"

#
# Abstract WBC Task.
#
#  configureHook:
#
#  1. Load robot models and add task frames
#  2. Configure constraints and create dynamic ports
#  3. Conigure solver
#
#  updateHook:
#
#  1. Update robot models
#  2. Update constraints
#  3. Setup constraints for optimization problem
#  4. Solve opt. problem
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("urdf_models", "std/vector<wbc/RobotModelConfig>").
        doc("Add multiple robot and/or object models.")

    property("base_frame", "std/string")
       doc("Name of the robot base frame; all computations will be performed with respect to this frame")

    property("urdf", "std/string").
        doc("Path to single urdf model. This is only for backward compatibility! Rather use the urdf_models property.")

    property("joint_names", "std/vector<std/string>").
       doc("Optionally set the order of joints here. If empty, order will be arbitrary.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcVelocityTask will dynamically create the following input ports for each constraint:
             Cartesian constraints:
                 Reference Input (/base/samples/RigidBodyState):         ref_<constraint_name>
                 Weights (/base/VectorXd):                               weight_<constraint_name>
                 Activation function (double):                           activation_<constraint_name>
                 Constraint pose output (/base/samples/RigidBodyState):  pose_<constraint_name>
                 Constraint output port (wbc/Constraint)                 constraint_<constraint_name>
             Joint Space constraints:
                 Reference Input (/base/samples/Joints):                 ref_<task_name>
                 Weights (/base/VectorXd):                               weight_<task_name>
                 Activation function (double):                           activation_<task_name>
                 Current joint state output (base/samples/Joints):       joint_state_<task_name>
                 Constraint output port (wbc/Constraint)                 constraint_<constraint_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/RigidBodyState"
    dynamic_output_port /.*/, "/base/samples/Joints"
    dynamic_output_port /.*/, "/wbc/Constraint"

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required.")

    output_port("ctrl_out", "base/commands/Joints").
       doc("Control solution")

    output_port("task_frames", "std/vector<wbc/TaskFrame>").
       doc("All task frames used in wbc.")

    output_port("computation_time", "double").
       doc("Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Actual cycle time between two consecutive calls of updateHook() in seconds")

    periodic 0.01
end

#
# Velocity based implementation of WBC. Uses KDL for kinematics computation
#
task_context "WbcVelocityTask" do subclasses "WbcTask"
    needs_configuration

    property("norm_max", "double", 10.0).
       doc("Maximum allowed norm of the solution. An infinite value will provide the most accurate, but eventually unbounded solution")

    property("epsilon", "double", 1e-9).
       doc("Precision for eigenvalue inversion. Required to ensure numerical stability. Inverse of an Eigenvalue smaller than this will be set to zero")

    property("initial_joint_weights", "base/VectorXd").
        doc("Joint weights control the contribution of each individual joint to the task solution. A zero means here that the joint is not used at all.
             Size has to be same as joint_names")

    property("max_solver_output", "base/VectorXd").
        doc("Maximum joint velocity (in rad/sec) for each joint. If empty, infinite output will be allowed. If not empty, size has to be same as number of joints")

    property("compute_debug", "bool", false).
        doc("Compute debug data like manipulability, condition numbers, error between solution and desired values etc.")

    input_port("joint_weights", "base/VectorXd").
       doc("Online set new joint weights")

    output_port("current_joint_weights", "base/VectorXd").
       doc("Currently used joint weights")

    #output_port("singular_values_pp", "std/vector<base/VectorXd>").
    #   doc("Singular values for each priority")

    output_port("damping_pp", "base/VectorXd").
       doc("Damping coefficient for each priority")

    output_port("inv_condition_number_pp", "base/VectorXd").
       doc("Inverse Condition number (ratio smallest to biggest singular value) for each priority")

    output_port("manipulability_pp", "base/VectorXd").
       doc("Manipulability measure, product of singular values")

    periodic 0.01
end

typekit do
   export_types "wbc/RobotModelConfig"
   export_types "wbc/Constraint"
   export_types "wbc/ConstraintConfig"
   export_types "wbc/TaskFrame"
end
