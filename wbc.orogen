name "wbc"

using_library "wbc-scenes"
using_library "wbc-robot_models"
using_library "base-types"


import_types_from "wbc/core/ConstraintConfig.hpp"
import_types_from "wbc/core/ConstraintStatus.hpp"
import_types_from "wbc/core/RobotModelConfig.hpp"
import_types_from "wbc/types/QuadraticProgram.hpp"
import_types_from "base"

#
# Base WBC Task.
#
#  configureHook:
#
#  1. Load and configure robot models
#  2. Configure wbc scene
#  3. Create dynamic ports
#
#  updateHook:
#
#  1. Read input ports
#  2. Update robot models
#  3. Update constraints and send them to the solver
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("joint_names", "std/vector<std/string>").
       doc("Optionally set the order of joints here. If empty, order will be as in the robot model.")

    property("base_frame", "std/string")
       doc("Name of the robot base frame; all computations will be performed with respect to this frame. If empty, base frame will be the base frame of the first given robot model.")

    property("robot_models", "std/vector<wbc/RobotModelConfig>").
        doc("Add multiple robot and/or object models.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcTask will dynamically create the following ports for each constraint:
             Cartesian constraints:
                 [in] Reference Input (/base/samples/RigidBodyStateSE3):         ref_<constraint_name>
                 [in] Weights (/base/VectorXd):                      weight_<constraint_name>
                 [in] Activation function (double):                  activation_<constraint_name>
                 [out] Constraint pose output (/base/samples/RigidBodyStateSE3): status_<constraint_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>
             Joint Space constraints:
                 [in] Reference Input (/base/samples/Joints):            ref_<task_name>
                 [in] Weights (/base/VectorXd):                          weight_<task_name>
                 [in] Activation function (double):                      activation_<task_name>
                 [out] Current joint state output (base/samples/Joints): status_<task_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyStateSE3"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/RigidBodyStateSE3"
    dynamic_output_port /.*/, "/base/samples/Joints"

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required. All configured joints have to be in this vector.")

    input_port("solver_output", "base/commands/Joints").
       doc("Computed solver output. Is used to compute the status of the constraint for debug purposes")

    output_port("computation_time", "double").
       doc("Debug: Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Debug: Actual cycle time between two consecutive calls of updateHook() in seconds")

    output_port("hierarchical_qp", "wbc/HierarchicalQP").
        doc("Output quadratic program for the solver.")

    output_port("robot_models_state", "wbc/RobotModelsState").
        doc("Current robot model status vector")

    operation("activateConstraint").
       argument("constraint_name", "std/string").
       argument("activation", "double")

    operation("activateConstraints").
       argument("constraint_names", "std/vector<std/string>").
       argument("activation", "double")

    operation("deactivateAllConstraints")

    periodic 0.01
end


#
# Velocity based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcVelocityTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end


#
# Acceleration based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcAccelerationTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end

#
# Convert samples of type base/samples/CartesianState to type base/samples/RigidBodyState and vice versa
#
task_context "RbsToCartesianStateTask" do
    needs_configuration

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/RigidBodyState")

    port_driven
end

#
# Convert samples of type base/samples/RigidBodyState to type base/samples/CartesianState
#
task_context "CartesianStateToRbsTask" do
    needs_configuration

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/CartesianState")

    port_driven
end

typekit do
   export_types "wbc/ConstraintStatus"
   export_types "wbc/RobotModelsState"
end

