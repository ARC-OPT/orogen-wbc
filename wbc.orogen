name "wbc"

import_types_from "wbcTypes.hpp"
import_types_from "wbc/ConstraintConfig.hpp"
import_types_from "wbc/Constraint.hpp"
import_types_from "wbc/HierarchicalWDLSSolver.hpp"
import_types_from "wbc/PriorityData.hpp"
import_types_from "base"
using_library "wbc"
using_library "kdl_parser"
using_library "kdl_conversions"

task_context "WbcVelocityTask" do
    needs_configuration

    property("urdf", "std/string").doc("Robot model file")

    property("joint_names", "std/vector<std/string>").
        doc("Define order of Joints that is used internally (for easier debugging)")

    property("reduced_tree", "std/vector<wbc/SubChainConfig>").
        doc("Define sub chains if not the complete KDL tree shall be used")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcVelocityTask will dynamically create the following input ports for each constraints:
             Cartesian constraints: ref_p<prio>_cart_<task_name>, weight_p<prio>_cart_<task_name>
             Joint Space constraints: ref_p<prio>_jnt_<task_name>, weight_p<prio>_jnt_<task_name>")

    property("norm_max", "double").
        doc("Maximum allowed norm of robot joint velocities in rad/sec. A very high value will provide an accurate solution, 
             but also high joint velocities in singular configurations.")

    property("initial_joint_weights", "/base/VectorXd").
        doc("Initial values for the joint weights. If not set here, all values will be one. If not empty,
             size has to be same as no of joints: Note: A high value here means that the corresponding
             joint will be used less")

    property("task_timeout", "double", 1.0).
        doc("Task timeout in seconds. A task will be considered as stopped, if no new data comes in for more than <task_timeout> seconds.
             In that case the task activation and its task velocity will be set to 0. If this value is set to .nan, no task timeout will be used.")

    property("debug", "bool", false).
        doc("Compute debug data and write it to ports. Set to false to avoid higher computation time.")

    property("svd_method", "wbc/svd_method").
        doc("Type of Singular Value Decomposition used. Can be one of wbc/svd_eigen(0) and wbc/svd_kdl(1)")

    property("tasks_active", "bool", true).
        doc("Defines the initial task state. If true, all task weights will be 1 at startup (tasks active), otherwise 0 (tasks inactive)")
    
    #These dynamic ports are created according to the 'wbc_config'

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"

    input_port("joint_weights", "/base/VectorXd").
         doc("Input size must be no_joints. Entries must be > 0. A higher value means that the corresponding joint is used less")
    output_port("current_joint_weights", "/base/VectorXd").
         doc("Currently used joint weights")
    input_port("joint_state", "/base/samples/Joints")
    output_port("ctrl_out", "base/commands/Joints")

    #Debug ports

    output_port "sample_time", "double"
    dynamic_output_port /.*/, "wbc/Constraint"
    dynamic_output_port /.*/, "wbc/PriorityData"
    dynamic_output_port /.*/, "/base/samples/RigidBodyState"

    periodic 0.01
end

typekit do
   export_types "wbc/Constraint"
   export_types "wbc/ConstraintConfig"
   export_types "wbc/PriorityData"
end


######################################################################################################################################################

task_context "RobotModelKDL" do
    needs_configuration
    
    # Want a specific order of joints used in the Jacobians? If not, leave empty!
    property "joint_names", "std/vector<std/string>"
    # URDF model file.
    property "urdf", "std/string"
    # Optionally define sub chains if not the complete KDL tree shall be used.
    property "reduced_tree", "std/vector<wbc/SubChainConfig>"

    # Joint state input. Thsi has to contain at least each joint that is used in a task frame chain. Order of joints is arbitrary.
    input_port "joint_state", "/base/samples/Joints"

    # Debug: Compute sample time
    output_port "actual_cycle_time", "double"

    # Jacobians computed for each task frame.
    dynamic_output_port(/.*/, "/base/MatrixXd")
    # Poses computed for each task frame.
    dynamic_output_port(/.*/, "/base/samples/RigidBodyState")

    # Add a task frame to the robot model. ID has to be a link in the URDF model. This will autogenerate the corresponding ports. Returns true in case of success, otherwise false.
    operation("addTaskFrame").
       returns("bool").
       argument("id","std/string")

    port_driven "joint_state"
end

