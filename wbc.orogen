name "wbc"

using_library "base-types"
using_library "wbc-scenes"
using_library "wbc-robot_models"
using_library "wbc-core"

import_types_from "base"
import_types_from "wbc/core/ConstraintConfig.hpp"
import_types_from "wbc/core/ConstraintStatus.hpp"
import_types_from "wbc/core/RobotModelConfig.hpp"
import_types_from "wbc/types/QuadraticProgram.hpp"
import_types_from "base/samples/RigidBodyStateSE3.hpp" # Workaround until we have RigidBodyStateSE3 in base/orogen/types

#
# Base WBC Task.
#
#  configureHook:
#
#  1. Load and configure robot models
#  2. Configure wbc scene
#  3. Create dynamic ports
#
#  updateHook:
#
#  1. Read input ports
#  2. Update robot models
#  3. Update constraints and send them to the solver
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("robot_models", "std/vector<wbc/RobotModelConfig>").
        doc("Add multiple robot and/or object models. The root of the first robot model will be used as base frame. The other models will be added in
             the given order by attaching the root of the model to the specified hook frame of the overall model. Each model will be attached with a
             6 DoF linkage between the specified hook and the root link of the attached model. This 6 DoF linkage is modelled as 6 virtual, unactuated joints
             (3 translational, 3 rotational) with naming scheme (and order):
             <root>_trans_x, <root>_trans_y, <root>_trans_z
             <root>_rot_x, <root>_rot_y, <root>_rot_z")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcTask will dynamically create the following ports for each constraint:
             Cartesian constraints:
                 [in] Reference Input (/base/samples/RigidBodyStateSE3):         ref_<constraint_name>
                 [in] Weights (/base/VectorXd):                      weight_<constraint_name>
                 [in] Activation function (double):                  activation_<constraint_name>
                 [out] Constraint pose output (/base/samples/RigidBodyStateSE3): status_<constraint_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>
             Joint Space constraints:
                 [in] Reference Input (/base/samples/Joints):            ref_<task_name>
                 [in] Weights (/base/VectorXd):                          weight_<task_name>
                 [in] Activation function (double):                      activation_<task_name>
                 [out] Current joint state output (base/samples/Joints): status_<task_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/RigidBodyStateSE3"
    dynamic_output_port /.*/, "/base/samples/Joints"

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required. All configured joints have to be in this vector.")

    input_port("solver_output", "base/commands/Joints").
       doc("Computed solver output. Is used to compute the status of the constraint for debug purposes")

    output_port("computation_time", "double").
       doc("Debug: Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Debug: Actual cycle time between two consecutive calls of updateHook() in seconds")

    output_port("hierarchical_qp", "wbc/HierarchicalQP").
        doc("Output quadratic program for the solver.")

    output_port("full_joint_state", "base/samples/Joints").
        doc("Complete joint state including virtual joints as used by the solver.")

    operation("activateConstraint").
       argument("constraint_name", "std/string").
       argument("activation", "double")

    operation("activateConstraints").
       argument("constraint_names", "std/vector<std/string>").
       argument("activation", "double")

    operation("deactivateAllConstraints")

    periodic 0.01
end

#
# Velocity based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
# The tasks are modeled as linear equality constraints Ax=y to a simplified QP with H=I and g=0
#
task_context "WbcVelocityTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end

#
# Same as WBC Velocity Task, only that the tasks are modeled as part of the objective function with H=A^T*A and g=-(A^T*y)^T
# Additionally, an adaptive damping strategy can be used to pass safely through kinematic singularties
#
task_context "WbcVelocityQuadraticCostTask", subclasses: "WbcTask" do
    needs_configuration

    property("min_eval_damping_threshold", "double", 0.001).
        doc("Threshold value that controls the damping. If thresh=0, no damping will be applied. If thresh > 0, e.g. 0.001, the reference velocities in task space
             will be reduced by multiplying them with a scalar damping factor d. The damping factor is determined from the smallest Eigenvalue s_min of the constraint matrix
             A as follows:
             d = 1, if s_min > min_eval_damping_threshold
             d = s_min * (1-min_eval_damping_threshold)/(min_eval_damping_threshold) + 1e-6, else
             As a result, the task space velocities will be downscaled linearly from 1 to near 0 if the robot is close to a singular configuration.")

    output_port("current_damping_factor", "double").
        doc("The current value of the damping factor")

    periodic 0.01
end

#
# Acceleration based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcAccelerationTask", subclasses: "WbcTask" do
    needs_configuration

    periodic 0.01
end

#
# Convert samples of type base/samples/CartesianState to type base/samples/RigidBodyState and vice versa
#
task_context "RbsToCartesianStateTask" do
    needs_configuration

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/RigidBodyState")

    port_driven
end

#
# Convert samples of type base/samples/RigidBodyState to type base/samples/CartesianState
#
task_context "CartesianStateToRbsTask" do
    needs_configuration

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/CartesianState")

    port_driven
end


typekit do
   export_types "wbc/ConstraintStatus"
end

