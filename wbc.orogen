name "wbc"

using_library "base-types"
using_library "kdl_parser"
using_library "wbc-core"
using_library "wbc-scenes"
using_library "wbc-robot_models-kdl"
using_library "wbc-robot_models-hyrodyn"
using_library "wbc-solvers-hls"
using_library "wbc-solvers-qpoases"

import_types_from "base"
import_types_from "wbc/core/ConstraintConfig.hpp"
import_types_from "wbc/core/ConstraintStatus.hpp"
import_types_from "wbc/core/RobotModelConfig.hpp"
import_types_from "wbc/core/QuadraticProgram.hpp"
import_types_from "base/samples/RigidBodyStateSE3.hpp" # Workaround until we have RigidBodyStateSE3 in base/orogen/types
import_types_from "qpOASES/MessageHandling.hpp"
import_types_from "qpOASES/Options.hpp"
import_types_from "wbcTypes.hpp"

#
# Base WBC Task.
#
#  configureHook:
#
#  1. Load and configure robot models
#  2. Configure wbc scene
#  3. Create dynamic ports
#
#  updateHook:
#
#  1. Read input ports
#  2. Update robot models
#  3. Update constraints and send them to the solver
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("robot_model", "wbc/RobotModelConfig").
        doc("Configuration of the robot model. See wbc/core/RobotModelConfig.hpp for details.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcTask will dynamically create the following ports for each constraint:
             Cartesian constraints:
                 [in] Reference Input (/base/samples/RigidBodyStateSE3):         ref_<constraint_name>
                 [in] Weights (/base/VectorXd):                      weight_<constraint_name>
                 [in] Activation function (double):                  activation_<constraint_name>
                 [out] Constraint pose output (/base/samples/RigidBodyStateSE3): status_<constraint_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>
             Joint Space constraints:
                 [in] Reference Input (/base/samples/Joints):            ref_<task_name>
                 [in] Weights (/base/VectorXd):                          weight_<task_name>
                 [in] Activation function (double):                      activation_<task_name>
                 [out] Current joint state output (base/samples/Joints): status_<task_name>
                 [out] Constraint status output (/wbc/ConstraintStatus): constraint_<constraint_name>")

    property("initial_joint_weights", "wbc/JointWeights").
        doc("The joint weights control the contribution of each individual joint to the task solution. Values have to be within (0 <= wq <= 1). A zero means here that the joint is not used at all. Size has to be same as number of robot joints or empty, in which case each joint weight is set to 1.")

    property("compute_constraint_status", "bool", true).
        doc("For debugging purpose: Compute the current status for each constraint, which contains (a) the solver output projected to task space (desired task space motion) and
             (b) the actual task space motion")

    property("integrate", "bool", true).
        doc("Perform numerical integration on the solver output, e.g. if output is acceleration type, integrate twice to get velocity and acceleration")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyStateSE3"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/Joints"

    input_port("joint_weights", "wbc/JointWeights").
       doc("Update joint weight values. Size has to be same number of joints.")

    input_port("floating_base_state", "base/samples/RigidBodyStateSE3").
       doc("Pose, Twist and spatial acceleration of the 6 dof floating base.")

    input_port("floating_base_state_deprecated", "base/samples/RigidBodyState").
       doc("Deprecated: In future the port floating_base_state should be used")

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required. All configured joints have to be in this vector.")

    input_port("contact_points", "std/vector<std/string>").
       doc("Set active contact points. The given names have to a valid link in the robot model.
            Depending on the implementation this will change the qp according to the current contact configuration")

    input_port("contact_wrenches", "base/samples/Wrenches").
       doc("Measured contact wrenches. The given names have to be consistent with the configured contact points")

    output_port("solver_output", "base/commands/Joints").
       doc("Computed solver output")

    output_port("com", "base/samples/RigidBodyStateSE3").
       doc("Current center of mass")

    output_port("current_joint_weights", "wbc/JointWeights").
        doc("Debug: Current joint weight vector")

    output_port("timing_stats", "wbc/TimingStats").
       doc("Debug: Statistics on computation time")

    output_port("current_qp", "wbc/HierarchicalQP").
        doc("Debug: Output quadratic prosolver_outputgram for the solver.")

    output_port("full_joint_state", "base/samples/Joints").
        doc("Debug: Complete joint state including virtual joints as used by the solver.")

    operation("activateConstraint").
       argument("constraint_name", "std/string").
       argument("activation", "double")

    operation("activateConstraints").
       argument("constraint_names", "std/vector<std/string>").
       argument("activation", "double")

    operation("deactivateAllConstraints")

    periodic 0.001
end

#
# Velocity based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
# The tasks are modeled as linear equality constraints Ax=y to a simplified QP with H=I and g=0
#
task_context "WbcVelocityTask", subclasses: "WbcTask" do
    needs_configuration

    property("norm_max", "double", 10.0).
       doc("Maximum allowed norm of the solution. An infinite value will provide the most accurate, but eventually unbounded solution. A lower value will prevent unbounded control velocities near singular configurations.")

    property("epsilon", "double", 1e-9).
       doc("Precision for eigenvalue inversion. Required to ensure numerical stability. Inverse of an Eigenvalue smaller than this will be set to zero")

    property("compute_id", "bool", false)
       .doc("Optionally compute the inverse dynamics solution given the solver output")

    periodic 0.001
end


#
# Velocity based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
# The tasks are embedded in the cost function here
#
task_context "WbcVelocityQuadraticCostTask", subclasses: "WbcTask" do
    needs_configuration

    property("solver_options", "qpOASES/Options").
       doc("User options for solving the QP. The entries of this struct will be set to sane default values. Check QPOases documentation before changing any of the entries,
            as that can have a large influence on success of solving the optimization problem")

    property("n_wsr", "int", 10).
       doc("Maximum number of working set recalculations performed by the solver")

    property("hessian_regularizer", "double", 1e-8).
       doc("This value is added to the diagonal of the Hessian matrix inside the QP to reduce the risk of infeasibility. Default is 1e-8")

    property("compute_id", "bool", false)
       .doc("Optionally compute the inverse dynamics solution given the solver output")

    periodic 0.001
end

#
# Acceleration based implementation of the WBC Scene. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcAccelerationTask", subclasses: "WbcTask" do
    needs_configuration

    property("solver_options", "qpOASES/Options").
       doc("User options for solving the QP. The entries of this struct will be set to sane default values. Check QPOases documentation before changing any of the entries,
            as that can have a large influence on success of solving the optimization problem")

    property("n_wsr", "int", 10).
       doc("Maximum number of working set recalculations performed by the solver")

    property("hessian_regularizer", "double", 1e-8).
       doc("This value is added to the diagonal of the Hessian matrix inside the QP to reduce the risk of infeasibility. Default is 1e-8")

    output_port("solver_return_value", "qpOASES/returnValue").
       doc("Return value of the last QP problem calculation. See qpOASES/MessageHandling.hpp and qpOASES/SQProblem.hpp for details")

    output_port("obj_func_value", "double").
       doc("Return value of the last QP problem calculation. See qpOASES/MessageHandling.hpp and qpOASES/SQProblem.hpp for details")

    output_port("estimated_contact_wrenches", "base/samples/Wrenches").
       doc("Estimated contact wrenches")

    periodic 0.001
end

#
# Convert samples of type base/samples/CartesianState to type base/samples/RigidBodyState and vice versa
#
task_context "RbsToCartesianStateTask" do
    needs_configuration

    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_output_port /.*/, "/base/samples/RigidBodyStateSE3"

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/RigidBodyState")

    port_driven
end

#
# Convert samples of type base/samples/RigidBodyState to type base/samples/CartesianState
#
task_context "CartesianStateToRbsTask" do
    needs_configuration

    dynamic_input_port /.*/, "/base/samples/RigidBodyStateSE3"
    dynamic_output_port /.*/, "/base/samples/RigidBodyState"

    property("input_ports", "std/vector<std/string>").
        doc("Vector of names of the input ports of type base/samples/CartesianState")

    port_driven
end


typekit do
   export_types "wbc/ConstraintStatus"
end

