name "wbc"

import_types_from "wbcTypes.hpp"
import_types_from "wbc/ConstraintConfig.hpp"
import_types_from "wbc/Constraint.hpp"
import_types_from "base"
using_library "wbc"
using_library "kdl_parser"
using_library "kdl_conversions"

task_context "WbcVelocityTask" do
    needs_configuration

    runtime_states "WAITING_FOR_JOINT_STATE"

    property("urdf", "std/string").
        doc("URDF model file.")

    property("urdf_models", "std/vector<wbc/URDFModel").
        doc("Add multiple urdf models. Will be combined to one kdl tree internally.")

    property("base_frame", "std/string")
        doc("Name of the robot base frame; all computations will be performed with respect to this frame")

    property("joint_names", "std/vector<std/string>").
        doc("Specify order of joints here. This order will be used in all Jacobians, in the joint weights, in the ctrl output and in all debug outputs.
             All joints used in any constraint have to be specified here. Don't forget that the joints between the constraints' root frames and the robot's base frame also have to be specified.")

    property("norm_max", "double", 10.0).
       doc("Maximum allowed norm of the solution. An infinite value will provide the most accurate, but eventually unbounded solution")

    property("epsilon", "double", 1e-9).
       doc("Precision for eigenvalue inversion. Required to ensure numerical stability. Inverse of an Eigenvalue smaller than this will be set to zero")

    property("initial_joint_weights", "base/VectorXd").
        doc("Joint weights control the contribution of each individual joint to the task solution. A zero means here that the joint is not used at all.
             Size has to be same as joint_names")

    property("compute_debug", "bool", false).
        doc("Compute debug data like manipulability, condition numbers, error between solution and desired values etc.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcVelocityTask will dynamically create the following input ports for each constraint:
             Cartesian constraints:
                 Reference Input (/base/samples/RigidBodyState):         ref_<task_name>
                 Weights (/base/VectorXd):                               weight_<task_name>
                 Activation function (double):                           activation_<task_name>
                 Constraint pose output (/base/samples/RigidBodyState):  pose_<task_name>
             Joint Space constraints:
                 Reference Input (/base/samples/Joints):                 ref_<task_name>
                 Weights (/base/VectorXd):                               weight_<task_name>
                 Activation function (double):                           activation_<task_name>
                 Current joint state output (base/samples/Joints):       joint_state_<task_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/RigidBodyState"
    dynamic_output_port /.*/, "/base/samples/Joints"


    input_port("joint_weights", "base/VectorXd").
       doc("Online set new joint weights")

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required.")


    output_port("ctrl_out", "base/commands/Joints").
       doc("Control solution")

    output_port("task_frames", "std/vector<base/samples/RigidBodyState>").
       doc("Poses of all task frames used in wbc.")

    output_port("computation_time", "double").
       doc("Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Actual cycle time between two consecutive calls of updateHook() in seconds")

    output_port("constraints", "std/vector<wbc/ConstraintsPerPrio>").
       doc("Constraint data for debugging and monitoring")

    output_port("current_joint_weights", "base/VectorXd").
       doc("Currently used joint weights")

    output_port("singular_values_pp", "std/vector<base/VectorXd>").
       doc("Singular values for each priority")

    output_port("damping_pp", "base/VectorXd").
       doc("Damping coefficient for each priority")

    output_port("inv_condition_number_pp", "base/VectorXd").
       doc("Inverse Condition number (ratio smallest to biggest singular value) for each priority")

    output_port("manipulability_pp", "base/VectorXd").
       doc("Manipulability measure, product of singular values")

    operation("addURDFModel").
       returns("bool").
       argument("model", "wbc/URDFModel")

    periodic 0.01
end

typekit do
   export_types "wbc/URDFModel"
   export_types "wbc/Constraint"
   export_types "wbc/ConstraintConfig"
   export_types "wbc/ConstraintsPerPrio"
end
