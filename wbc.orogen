name "wbc"

import_types_from "wbc/ConstraintConfig.hpp"
import_types_from "wbc/Constraint.hpp"
import_types_from "wbc/RobotModelConfig.hpp"
import_types_from "base"
using_library "base-logging"
using_library "wbc"
using_library "kdl_parser"

#
# Abstract WBC Task.
#
#  configureHook:
#
#  1. Load and configure robot models
#  2. Conigure solver
#  3. Configure wbc scene
#  4. Create dynamic ports
#
#  updateHook:
#
#  1. Read input ports
#  2. Update robot models
#  3. Update constraints
#  4. Solve opt. problem
#
task_context "WbcTask" do abstract
    needs_configuration

    runtime_states "NO_JOINT_STATE"

    property("joint_names", "std/vector<std/string>").
       doc("Optionally set the order of joints here. If empty, order will be as in the robot model.")

    property("initial_joint_weights", "base/VectorXd").
        doc("Joint weights control the contribution of each individual joint to the task solution. A zero means here that the joint is not used at all.
             Size has to be same as number of robot joints")

    property("base_frame", "std/string")
       doc("Name of the robot base frame; all computations will be performed with respect to this frame. If empty, base frame will be the base frame of the first given robot model.")

    property("robot_models", "std/vector<wbc/RobotModelConfig>").
        doc("Add multiple robot and/or object models.")

    property("wbc_config", "std/vector<wbc/ConstraintConfig>").
        doc("Configuration of constraints. The WbcVelocityTask will dynamically create the following input ports for each constraint:
             Cartesian constraints:
                 Reference Input (/base/samples/RigidBodyState):         ref_<constraint_name>
                 Weights (/base/VectorXd):                               weight_<constraint_name>
                 Activation function (double):                           activation_<constraint_name>
                 Constraint pose output (/base/samples/RigidBodyState):  pose_<constraint_name>
                 Constraint output port (wbc/Constraint)                 constraint_<constraint_name>
             Joint Space constraints:
                 Reference Input (/base/samples/Joints):                 ref_<task_name>
                 Weights (/base/VectorXd):                               weight_<task_name>
                 Activation function (double):                           activation_<task_name>
                 Current joint state output (base/samples/Joints):       joint_state_<task_name>
                 Constraint output port (wbc/Constraint)                 constraint_<constraint_name>")

    # These dynamic ports are created according to the 'wbc_config' (see above)

    dynamic_input_port /.*/, "/base/samples/Joints"
    dynamic_input_port /.*/, "/base/samples/RigidBodyState"
    dynamic_input_port /.*/, "/base/VectorXd"
    dynamic_input_port /.*/, "/double"
    dynamic_output_port /.*/, "/base/samples/RigidBodyState"
    dynamic_output_port /.*/, "/base/samples/Joints"

    input_port("joint_state", "base/samples/Joints").
       doc("Current joint state of the robot. Right now, only positions are required. All configured joints have to be in this vector.")

    input_port("joint_weights", "base/VectorXd").
       doc("Online set new joint weights. Size has to be same number of joints.")

    output_port("ctrl_out", "base/commands/Joints").
       doc("Control solution. Size will be same as number of joints.")

    output_port("computation_time", "double").
       doc("Computation time for one cycle in seconds")

    output_port("actual_cycle_time", "double").
       doc("Actual cycle time between two consecutive calls of updateHook() in seconds")

    output_port("constraints", "std/vector<wbc/ConstraintsPerPrio>").
       doc("Debug: Vector with status information for all constraints.")

    output_port("current_joint_weights", "base/VectorXd").
       doc("Debug: Currently used joint weights")

    periodic 0.01
end

#
# Velocity based implementation of WBC. This implementation uses KDL for kinematics computation and URDF for model parsing.
#
task_context "WbcVelocityTask" do subclasses "WbcTask"
    needs_configuration

    property("norm_max", "double", 10.0).
       doc("Maximum allowed norm of the solution. An infinite value will provide the most accurate, but eventually unbounded solution. A lower value will prevent unbounded
            control velocities near singular configurations.")

    property("epsilon", "double", 1e-9).
       doc("Precision for eigenvalue inversion. Required to ensure numerical stability. Inverse of an Eigenvalue smaller than this will be set to zero")

    property("max_solver_output", "base/VectorXd").
        doc("Maximum joint velocity (in rad/sec) for each joint. If empty, infinite output will be allowed. If not empty, size has to be same as number of joints")

    periodic 0.01
end

typekit do
   export_types "wbc/RobotModelConfig"
   export_types "wbc/Constraint"
   export_types "wbc/ConstraintConfig"
   export_types "wbc/ConstraintsPerPrio"
end
